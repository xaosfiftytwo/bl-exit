#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
from __future__ import print_function

import os
display = os.environ.get('DISPLAY') != None

import os
import getopt
import getpass
import subprocess
import sys

me = 'bl-exit'
# Default errorMessages dict
# key = result from _can_do_it
# value = string shown in error_message_dialog
canDoItErrorMessages = dict(
    no         = "Action is not allowed.",
    na         = "Action is not available.",
    challenge  = "Action is not authorized."
)

# Translate command-line option to method - command line only
actionToMethod = dict(
    logout    = 'Logout',
    l         = 'Logout',
    suspend   = 'Suspend',
    s         = 'Suspend',
    hybridsleep = 'HybridSleep',
    y           = 'HybridSleep',
    hibernate = 'Hibernate',
    i         = 'Hibernate',
    reboot    = 'Reboot',
    b         = 'Reboot',
    poweroff  = 'PowerOff',
    p         = 'PowerOff'
)

# Custom exception class to test response value returned by can_do_it
class CanDoItError(Exception):
    pass

if display:
    import gtk
    import pygtk
    pygtk.require('2.0')
    import ConfigParser

    class Blexit(gtk.Window):
        """A dialog offering the user to log out, suspend, reboot or shut down."""

        def __init__(self):
            gtk.Window.__init__(self)
            self.set_title("Log out " + getpass.getuser() + "? Choose an option:")
            self.set_border_width(5)
            self.set_size_request(500, 80)
            self.set_resizable(False)
            self.set_keep_above(True)
            self.stick
            self.set_position(gtk.WIN_POS_CENTER)
            self.connect("delete_event", gtk.main_quit)
            windowicon = self.render_icon(gtk.STOCK_QUIT, gtk.ICON_SIZE_DIALOG)
            self.set_icon(windowicon)

            # Cancel key (Escape)
            accelgroup = gtk.AccelGroup()
            key, mod = gtk.accelerator_parse('Escape')
            accelgroup.connect_group(key, mod, gtk.ACCEL_VISIBLE, gtk.main_quit)
            self.add_accel_group(accelgroup)

            # Determine config dir, first try the environment variable XDG_CONFIG_HOME
            # according to XDG specification and as a fallback use ~/.config/bl-exit
            self.config_dir = (os.getenv('XDG_CONFIG_HOME') or os.path.expanduser('~/.config')) + '/bl-exit'        
            self.config = ConfigParser.RawConfigParser()
            if os.path.isfile(self.config_dir + '/bl-exitrc'):
                self.config.read(self.config_dir + '/bl-exitrc')
            self._bva = []
            self._construct_ui()
            
        def _construct_ui(self):
            self._button_box = gtk.HBox()
            self._add_button(1, self._cancel_action, stock=gtk.STOCK_CANCEL)
            self._build_button_visibility_array()
            for button in self._bva:
                (action, label, actionfunc, method, show, onError) = button
                if not show == 0:
                    self._add_button(show, actionfunc, label=label)
                self._status = gtk.Label()
                label_box = gtk.HBox()
                label_box.pack_start(self._status)

            vbox = gtk.VBox()
            vbox.pack_start(self._button_box)
            vbox.pack_start(label_box)

            self.add(vbox)
            self.show_all()

        def _build_button_visibility_array(self):
            ''' Determine button visibily using bl-exit configuration file.'''
            bva = [ ('logout', '_Log out', self._logout_action),
                    ('suspend', '_Suspend', self._suspend_action),
                    ('hibernate', 'H_ibernate', self._hibernate_action),
                    ('hybridsleep', 'H_ybrid sleep', self._hybridsleep_action),
                    ('reboot', 'Re_boot', self._reboot_action),
                    ('poweroff', '_Power off', self._shutdown_action)]
            # Values that the 'show' keyword can take in the configuration file
            show_values = dict(never = 0, always = 1, maybe = 2)
            # Values that the 'onerror' keyword can take in the configuration file
            onerror_values = dict ( novisual = 0, visual = 1)
            # Per button default settings
            per_button_defaults = dict (
                logout = 'always',
                suspend = 'always',
                hibernate = 'never',
                hybridsleep = 'never',
                reboot = 'always',
                poweroff = 'always'
            )
            # build self._bva, an array of tuples, containing
            # (action, label, actionfunction, actionMethod, show, onerror)
            for (action, label, actionfunction) in bva:
                # Defaults. 
                show = show_values[per_button_defaults[action]]
                onError = onerror_values['novisual']
                for section in [ 'default', action ]:
                    try:
                        getshow = self.config.get(section, 'show')
                        if getshow in show_values:
                            show = show_values[getshow]
                        if show == 2:
                            candoit = can_do_it(actionToMethod[action])
                            if candoit == 'yes':
                                show = 2
                            else:
                                show = 3
                        else:
                            pass
                    except ConfigParser.NoSectionError as e:
                        pass
                    except ConfigParser.NoOptionError as e:
                        pass
                    except subprocess.CalledProcessError as e:
                        print ("{}: {}".format(me, str(e)), file = sys.stderr)
                        pass

                    try:
                        getonerror = self.config.get(section, 'onerror')
                        if getonerror in onerror_values:
                            onError = onerror_values[getonerror]
                    except ConfigParser.NoSectionError as e:
                        pass
                    except ConfigParser.NoOptionError as e:
                        pass

                self._bva.append(tuple([action, label, actionfunction, actionToMethod[action], show, onError]))
            
        def main(self):
            gtk.main()

        def _add_button(self, show, action, label=None, stock=None):
            if stock is not None:
                button = gtk.Button(stock=stock)
            else:
                button = gtk.Button(label=label)
            if show == 3:
                button.set_sensitive(False)
            button.set_border_width(4)
            button.connect("clicked", action)
            self._button_box.pack_start(button)

        def _disable_buttons(self):
            self._button_box.foreach(lambda button: button.set_sensitive(False))

        def _cancel_action(self, button):
            self._disable_buttons()
            gtk.main_quit()

        def _get_onerror(self):
            for item in self._bva:
                (action, label, actionfunction, actionMethod, show, onerror) = item
                if action == self._selected_action:
                    return onerror
            
        def _on_error(self, e):
            onerror = self._get_onerror()
            if onerror == 0:
                print ("{}: {}".format(me, str(e)), file = sys.stderr)
                sys.exit(1)
            else: 
                emDialog = gtk.MessageDialog(parent=None, flags=0, type=gtk.MESSAGE_INFO,
                                             buttons=gtk.BUTTONS_OK, message_format=None)
                if emDialog:
                    emDialog.set_markup("{}".format(e))
                    emDialog.run()

        def _logout_action(self, button):
            self._disable_buttons()
            self._selected_action = 'logout'
            self._status.set_label("Exiting Openbox, please standby...")
            self._do_it("Logout")

        def _suspend_action(self, button):
            self._disable_buttons()
            self._selected_action = 'suspend'
            self._status.set_label("Suspending, please standby...")
            self._do_it("Suspend")

        def _hibernate_action(self, button):
            self._disable_buttons()
            self._selected_action = 'hibernate'
            self._status.set_label("Hibernating, please standby...")
            self._do_it("Hibernate")

        def _hybridsleep_action(self, button):
            self._disable_buttons()
            self._selected_action = 'hybridsleep'
            self._status.set_label("Hibernating + Sleeping, please standby...")
            self._do_it("HybridSleep")
            
        def _reboot_action(self, button):
            self._disable_buttons()
            self._selected_action = 'reboot'
            self._status.set_label("Rebooting, please standby...")
            self._do_it("Reboot")

        def _shutdown_action(self, button):
            self._disable_buttons()
            self._selected_action = 'poweroff'
            self._status.set_label("Shutting down, please standby...")
            self._do_it("PowerOff")

        def _do_it(self, action):
            try:
                if action == 'Logout':
                    openbox_exit()
                else:
                    do_it(action)
            except (subprocess.CalledProcessError, CanDoItError, KeyError) as e:
                self._on_error(e)
            finally:
                gtk.main_quit()

# All methods hereafter are either command-line processing specific
# or common between command-line and graphical processing.

def can_do_it(action):
    # There is no 'CanLogout' method
    if action == "Logout":
        return "yes"
    if action == "Hibernate":
        canDoItErrorMessages["na"] = """Action is not available.

Probable cause is inadequate swap space."""
    actionMethod = "Can{}".format(action)
    response = send_dbus(actionMethod)
    if response:
        lines = response.split("\n")
        if lines:
            words = lines[1].split("\"")
            if words:
                if words[1]:
                    return words[1]

def do_it(action):
    candoit = can_do_it(action)
    actionMethod = "Can{}".format(action)
    if candoit == "yes":
        send_dbus(action)
    elif candoit in canDoItErrorMessages:
        raise CanDoItError(
            "Function {} returned code \"{}\".\n{}".format(actionMethod, candoit,
                                                           canDoItErrorMessages[candoit]))
    else:
        raise CanDoItError(
            "Function {} returned unexpected reponse \"{}\".".format(actionMethod, candoit))

def send_dbus(method):
    arguments = ["dbus-send", "--print-reply", "--system", "--dest=org.freedesktop.login1",
                 "/org/freedesktop/login1", "org.freedesktop.login1.Manager.{}".format(method)]
    if method[:3] != "Can":
        arguments.append("boolean:true")
    response = subprocess.check_output(arguments)
    return response

def on_error(string):
    print ("{}".format(string), file = sys.stderr)
    sys.exit(1)

def openbox_exit():
    subprocess.check_output(["openbox", "--exit"])

def logout():
    try:
        openbox_exit()
    except subprocess.CalledProcessError as e:
        on_error(e.output)

def action_from_command_line(action):
    try:
        do_it(action)
    except (subprocess.CalledProcessError, CanDoItError, KeyError) as e:
        on_error("{}".format(e))

def print_usage(status):
    print ("bl-exit: usage:\n" \
        "  -h, --help      show this message and exit\n" \
        "  -l, --logout    log out from openbox\n" \
        "  -s, --suspend   suspend the system\n" \
        "  -i, --hibernate hibernate the system\n" \
        "  -y, --hybridsleep hibernate + sleep the system\n" \
        "  -b, --reboot    reboot the system\n" \
        "  -p, --poweroff  power the system down")
    sys.exit(status)
        
def cli_processing(display, argv):
    if display:
        short_options = "hlsyibp"
        long_options  = ["help","logout","suspend","hybridsleep","hibernate","reboot","poweroff"]
    else:
        if len(argv) == 0:
            print ('Required action is missing.', file=sys.stderr)
            sys.exit(1)
        short_options = "hsyibp"
        long_options  = ["help","suspend","hybridsleep", "hibernate","reboot","poweroff"]
    try:
        opts, args = getopt.getopt(argv, short_options, long_options)
    except getopt.GetoptError:
        print_usage(1)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print_usage(0)
        if opt in ("-l", "--logout"):
            logout()
            sys.exit(0)
        action_from_command_line(actionToMethod[opt.lstrip('-')])
        sys.exit(0)
    # no arguments
    print ("Required arguments missing.", file = sys.stderr)
    sys.exit(1)
        
def graphical_processing():
    gtk.gdk.threads_enter()
    Blexit().main()
    gtk.gdk.threads_leave()

def main(argv):
    '''
    In the absence of command line options, we presume processing in a graphical environment,
    showing a GTK window that allows the user to click a button for the action she wants.

    Otherwise processing from the command line is presumed and error messages go to stderr.
    '''
    if display and len(argv) == 0:
        graphical_processing()
    else:
        # Make it work from a console too
        cli_processing(display, argv)

if __name__ == "__main__":
    main(sys.argv[1:])
    sys.exit(0)
