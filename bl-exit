#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
from __future__ import print_function

import os
display = os.environ.get('DISPLAY') != None

import os
import getopt
import getpass
import subprocess
import sys

__me__ = 'bl-exit'
__version__ = '2.0.0'

# Default errorMessages dict
# key = result from _can_do_action
# value = string shown in error_message_dialog
canDoItErrorMessages = dict(
    no         = "Action is not allowed.",
    na         = "Action is not available.",
    challenge  = "Action is not authorized."
)

# Translate command-line option to method - command line only
actionToMethod = dict(
    logout    = 'Logout',
    l         = 'Logout',
    suspend   = 'Suspend',
    s         = 'Suspend',
    hybridsleep = 'HybridSleep',
    y           = 'HybridSleep',
    hibernate = 'Hibernate',
    i         = 'Hibernate',
    reboot    = 'Reboot',
    b         = 'Reboot',
    poweroff  = 'PowerOff',
    p         = 'PowerOff'
)

# Custom exception class to test response value returned by can_do_action
class CanDoItError(Exception):
    pass

if display:
    import gtk
    import pygtk
    pygtk.require('2.0')
    import ConfigParser

    class BlExitWindow(gtk.Window):
        """A dialog offering the user to log out, suspend, reboot or shut down."""

        def __init__(self):
            gtk.Window.__init__(self)
            self.set_title("Log out " + getpass.getuser() + "? Choose an option:")
            self.set_border_width(5)
            self.set_size_request(-1, 80)
            self.set_resizable(False)
            self.set_keep_above(True)
            self.stick
            self.set_position(gtk.WIN_POS_CENTER)
            self.connect("delete_event", gtk.main_quit)
            windowicon = self.render_icon(gtk.STOCK_QUIT, gtk.ICON_SIZE_DIALOG)
            self.set_icon(windowicon)

            # Cancel key (Escape)
            accelgroup = gtk.AccelGroup()
            key, mod = gtk.accelerator_parse('Escape')
            accelgroup.connect_group(key, mod, gtk.ACCEL_VISIBLE, gtk.main_quit)
            self.add_accel_group(accelgroup)

            # Determine config dir, first try the environment variable XDG_CONFIG_HOME
            # according to XDG specification and as a fallback use ~/.config/bl-exit
            # Use /etc/bl-exit/bl-exitrc as a last resort
            config_dirs=[]
            config_dirs.append(os.getenv('XDG_CONFIG_HOME'))
            config_dirs.append(os.path.expanduser('~/.config'))
            config_dirs.append('/etc')
            config_file = None
            for config_dir in config_dirs:
                if config_dir:
                    config_dir = config_dir + '/bl-exit'
                    if os.path.isdir(config_dir):
                        maybe_config_file = config_dir + '/bl-exitrc'
                        if os.path.isfile(maybe_config_file):
                            config_file = maybe_config_file
                            break
            if config_file:
                self.config = ConfigParser.RawConfigParser()
                self.config.read(config_file)
            else:
                self.config = None
            self._bva = []
            self._construct_ui()

        def _construct_ui(self):
            self._button_box = gtk.HBox()
            self._add_button(1, self._cancel_action, stock=gtk.STOCK_CANCEL)
            self._build_button_visibility_array()
            for button in self._bva:
                (action, label, actionfunc, method, show, onError) = button
                if not show == 0:
                    self._add_button(show, actionfunc, label=label)
            self._status = gtk.Label()
            label_box = gtk.HBox()
            label_box.pack_start(self._status)

            vbox = gtk.VBox()
            vbox.pack_start(self._button_box)
            vbox.pack_start(label_box)

            self.add(vbox)
            self.show_all()

        def _build_button_visibility_array(self):
            ''' Determine button visibily using bl-exit configuration file.'''
            bva = [ ('logout', '_Log out', self._logout_action),
                    ('suspend', '_Suspend', self._suspend_action),
                    ('hibernate', 'H_ibernate', self._hibernate_action),
                    ('hybridsleep', 'H_ybrid sleep', self._hybridsleep_action),
                    ('reboot', 'Re_boot', self._reboot_action),
                    ('poweroff', '_Power off', self._shutdown_action)]
            # build self._bva, an array of tuples, containing
            # (action, label, actionfunction, actionMethod, show, onerror)
            # Values that the 'show' keyword can take in the configuration file
            show_values = dict(never = 0, always = 1, maybe = 2)
            # Values that the 'onerror' keyword can take in the configuration file
            onerror_values = dict ( novisual = 0, visual = 1)
            # Per button default settings
            per_button_defaults = dict (
                logout = 'always',
                suspend = 'always',
                hibernate = 'never',
                hybridsleep = 'never',
                reboot = 'always',
                poweroff = 'always'
            )
            for (action, label, actionfunction) in bva:
                # Defaults.
                show = show_values[per_button_defaults[action]]
                onError = onerror_values['novisual']
                if self.config:
                    for section in [ 'default', action ]:
                        try:
                            getshow = self.config.get(section, 'show')
                            if getshow in show_values:
                                show = show_values[getshow]
                                if show == 2:
                                    candoit = can_do_action(actionToMethod[action])
                                    if not candoit == 'yes':
                                        show = 3
                            else:
                                pass
                        except ConfigParser.NoSectionError as e:
                            pass
                        except ConfigParser.NoOptionError as e:
                            pass
                        except subprocess.CalledProcessError as e:
                            print ("{}: {}".format(__me__, str(e)), file = sys.stderr)
                            pass

                    try:
                        getonerror = self.config.get(section, 'onerror')
                        if getonerror in onerror_values:
                            onError = onerror_values[getonerror]
                    except ConfigParser.NoSectionError as e:
                        pass
                    except ConfigParser.NoOptionError as e:
                        pass

                self._bva.append(tuple([action, label, actionfunction, actionToMethod[action],
                                        show, onError]))

        def main(self):
            gtk.main()

        def _add_button(self, show, action, label=None, stock=None):
            if stock is not None:
                button = gtk.Button(stock=stock)
            else:
                button = gtk.Button(label=label)
            button.set_size_request(100, 40)
            if show == 3:
                button.set_sensitive(False)
            button.set_border_width(4)
            button.connect("clicked", action)
            self._button_box.pack_start(button)

        def _disable_buttons(self):
            self._button_box.foreach(lambda button: button.set_sensitive(False))

        def _cancel_action(self, button):
            self._disable_buttons()
            gtk.main_quit()

        def _get_onerror(self):
            for item in self._bva:
                (action, label, actionfunction, actionMethod, show, onerror) = item
                if action == self._selected_action:
                    return onerror

        def _on_error(self, e):
            onerror = self._get_onerror()
            if onerror == 0:
                print ("{}: {}".format(__me__, str(e)), file = sys.stderr)
                sys.exit(1)
            else:
                emDialog = gtk.MessageDialog(parent=None, flags=0, type=gtk.MESSAGE_INFO,
                                             buttons=gtk.BUTTONS_OK, message_format=None)
                if emDialog:
                    emDialog.set_markup("{}".format(e))
                    emDialog.run()

        def _logout_action(self, button):
            self._disable_buttons()
            self._selected_action = 'logout'
            self._status.set_label("Exiting Openbox, please standby...")
            self._do_action("Logout")

        def _suspend_action(self, button):
            self._disable_buttons()
            self._selected_action = 'suspend'
            self._status.set_label("Suspending, please standby...")
            self._do_action("Suspend")

        def _hibernate_action(self, button):
            self._disable_buttons()
            self._selected_action = 'hibernate'
            self._status.set_label("Hibernating, please standby...")
            self._do_action("Hibernate")

        def _hybridsleep_action(self, button):
            self._disable_buttons()
            self._selected_action = 'hybridsleep'
            self._status.set_label("Hibernating + Sleeping, please standby...")
            self._do_action("HybridSleep")

        def _reboot_action(self, button):
            self._disable_buttons()
            self._selected_action = 'reboot'
            self._status.set_label("Rebooting, please standby...")
            self._do_action("Reboot")

        def _shutdown_action(self, button):
            self._disable_buttons()
            self._selected_action = 'poweroff'
            self._status.set_label("Shutting down, please standby...")
            self._do_action("PowerOff")

        def _do_action(self, action):
            try:
                if action == 'Logout':
                    openbox_exit()
                else:
                    do_action(action)
            except (subprocess.CalledProcessError, CanDoItError, KeyError) as e:
                self._on_error(str(e))
            finally:
                gtk.main_quit()

def can_do_action(action):
    # There is no 'CanLogout' method
    if action == "Logout":
        return "yes"
    if action == "Hibernate":
        canDoItErrorMessages["na"] = """{} is not available.
Probable cause is inadequate swap space.""".format(action)
    actionMethod = "Can{}".format(action)
    response = send_dbus(actionMethod)
    if response:
        lines = response.split("\n")
        if lines:
            words = lines[1].split("\"")
            if words:
                if words[1]:
                    return words[1]

def do_action(action):
    candoit = can_do_action(action)
    actionMethod = "Can{}".format(action)
    if candoit == "yes":
        send_dbus(action)
    elif candoit in canDoItErrorMessages:
        raise CanDoItError(
            "Function {} returned code \"{}\".\n{}".format(actionMethod, candoit,
                                                           canDoItErrorMessages[candoit]))
    else:
        raise CanDoItError(
            "Function {} returned unexpected reponse \"{}\".".format(actionMethod, candoit))

def send_dbus(method):
    arguments = ["dbus-send", "--print-reply", "--system", "--dest=org.freedesktop.login1",
                 "/org/freedesktop/login1", "org.freedesktop.login1.Manager.{}".format(method)]
    if method[:3] != "Can":
        arguments.append("boolean:true")
    response = subprocess.check_output(arguments)
    return response

def on_error(string):
    print ("{}".format(string), file = sys.stderr)
    sys.exit(1)

def openbox_exit():
    subprocess.check_output(["openbox", "--exit"])

def logout():
    try:
        openbox_exit()
    except subprocess.CalledProcessError as e:
        on_error(e.output)

def action_from_command_line(action):
    try:
        do_action(action)
    except (subprocess.CalledProcessError, CanDoItError, KeyError) as e:
        on_error("{}".format(str(e)))

def print_usage(status):
    print ("bl-exit version {} usage:".format(__version__),
           "  -h, --help        show this message and exit",
           "  -l, --logout      log out from openbox",
           "  -s, --suspend     suspend the system",
           "  -i, --hibernate   hibernate the system",
           "  -y, --hybridsleep hibernate + sleep the system",
           "  -b, --reboot      reboot the system",
           "  -p, --poweroff    power the system down", sep='\n', end='\n', file=sys.stderr)
    sys.exit(status)

def cli_processing(argv):
    if display:
        short_options = "hlsyibp"
        long_options  = ["help","logout","suspend","hybridsleep","hibernate","reboot","poweroff"]
    else:
        if len(argv) == 0:
            print ('Required action is missing.', file=sys.stderr)
            sys.exit(1)
        short_options = "hsyibp"
        long_options  = ["help","suspend","hybridsleep", "hibernate","reboot","poweroff"]

    try:
        opts, args = getopt.getopt(argv, short_options, long_options)
    except getopt.GetoptError:
        print_usage(1)

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print_usage(0)
        else:
            if opt in ("-l", "--logout"):
                logout()
            else:
                action_from_command_line(actionToMethod[opt.lstrip('-')])
            sys.exit(0)

    # no arguments
    print ("Required arguments missing.", file = sys.stderr)
    sys.exit(1)

def graphical_processing():
    BlExitWindow().main()

def main(argv):
    '''
    The script works both in a graphical and a non-graphical environment.

    In a graphical environment, the BlExitWindow instance is only shown when the script is launched
    without arguments. The user selects the action she wants by clicking the right button.

    Hen  the script is launched In a graphical environment the requested action should be one of the
    accepted arguments and the action is executed without asking for confirmation - as if the script
    was launched from the command line.

    In a non-graphical environment, one of the accepted actions must be specified as an argument.
    '''
    if display and len(argv) == 0:
        graphical_processing()
    else:
        # Make it work from a console too
        cli_processing(argv)

if __name__ == "__main__":
    main(sys.argv[1:])
    sys.exit(0)
